// -*- C++ -*-
// File generated by PyFoam - sorry for the ugliness

FoamFile
{
 version 2.0;
 format ascii;
 class dictionary;
 object snappyHexMeshDict;
}

castellatedMesh yes;
snap yes;
addLayers yes;
geometry
{
  chamber.stl
  {
    type triSurfaceMesh;
    name "chamber";
    regions
    {
      patch0
      {
        name Wall;
      }
      patch1
      {
        name Wall;
      }
      patch10
      {
        name Wall;
      }
      patch11
      {
        name Wall;
      }
      patch12
      {
        name Wall;
      }
      patch13
      {
        name Wall;
      }
      patch14
      {
        name Wall;
      }
      patch15
      {
        name Wall;
      }
      patch16
      {
        name Wall;
      }
      patch17
      {
        name Wall;
      }
      patch18
      {
        name Wall;
      }
      patch19
      {
        name In;
      }
      patch2
      {
        name Wall;
      }
      patch20
      {
        name Wall;
      }
      patch21
      {
        name Wall;
      }
      patch22
      {
        name Wall;
      }
      patch23
      {
        name Wall;
      }
      patch3
      {
        name Wall;
      }
      patch4
      {
        name Wall;
      }
      patch5
      {
        name Wall;
      }
      patch6
      {
        name Wall;
      }
      patch7
      {
        name Out;
      }
      patch8
      {
        name Wall;
      }
      patch9
      {
        name Wall;
      }
    }
    file "/media/sf_Mpacts_tool/E2CMchamber_named_named.stl";
  }
} 	// Settings for the castellatedMesh generation.

castellatedMeshControls
{
  maxLocalCells 100000;
  maxGlobalCells 2000000; 	// Refinement parameters// ~~~~~~~~~~~~~~~~~~~~~// If local number of cells is >= maxLocalCells on any processor// switches from from refinement followed by balancing// (current method) to (weighted) balancing before refinement.// Overall cell limit (approximately). Refinement will stop immediately// upon reaching this number so a refinement level might not complete.// Note that this is the number of cells before removing the part which// is not 'visible' from the keepPoint. The final number of cells might// actually be a lot less.// The surface refinement loop might spend lots of iterations// refining just a few cells. This setting will cause refinement// to stop if <= minimumRefine are selected for refinement. Note:// it will at least do one iteration (unless the number of cells// to refine is 0)
  minRefinementCells 2; 	// Number of buffer layers between different levels.// 1 means normal 2:1 refinement restriction, larger means slower// refinement.
  nCellsBetweenLevels 2; 	// Explicit feature edge refinement// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~// Specifies a level for any cell intersected by its edges.// This is a featureEdgeMesh, read from constant/triSurface for now.
  features
    (

      {
        file "chamber.extendedFeatureEdgeMesh";
        level 3;

      }
    ); 	// Surface based refinement// ~~~~~~~~~~~~~~~~~~~~~~~~// Specifies two levels for every surface. The first is the minimum level,// every cell intersecting a surface gets refined up to the minimum level.// The second level is the maximum level. Cells that 'see' multiple// intersections where the intersections make an// angle > resolveFeatureAngle get refined up to the maximum level.
  refinementSurfaces
  {
    chamber
    {
      level
        (
          1
          2
        );
    }
  } 	// Surface-wise min and max refinement level// Resolve sharp angles
  resolveFeatureAngle 30; 	// Region-wise refinement// ~~~~~~~~~~~~~~~~~~~~~~// Specifies refinement level for cells in relation to a surface. One of// three modes// - distance. 'levels' specifies per distance to the surface the//   wanted refinement level. The distances need to be specified in//   descending order.// - inside. 'levels' is only one entry and only the level is used. All//   cells inside the surface get refined up to the level. The surface//   needs to be closed for this to be possible.// - outside. Same but cells outside.
  refinementRegions
  {
  } 	// Mesh selection// ~~~~~~~~~~~~~~// After refinement patches get added for all refinementSurfaces and// all cells intersecting the surfaces get put into these patches. The// section reachable from the locationInMesh is kept.// NOTE: This point should never be on a face, always inside a cell, even// after refinement.
  locationInMesh (0 0 0); 	// Whether any faceZones (as specified in the refinementSurfaces)// are only on the boundary of corresponding cellZones or also allow// free-standing zone faces. Not used if there are no faceZones.
  allowFreeStandingZoneFaces no;
} 	// Settings for the snapping.

snapControls
{
  nSmoothPatch 4;
  tolerance 1.0; 	//- Number of patch smoothing iterations before finding correspondence//  to surface//- Relative distance for points to be attracted by surface feature point//  or edge. True distance is this factor times local//  maximum edge length.//- Number of mesh displacement relaxation iterations.
  nSolveIter 300; 	//- Maximum number of snapping relaxation iterations. Should stop//  before upon reaching a correct mesh.
  nRelaxIter 8; 	//- Highly experimental and wip: number of feature edge snapping//  iterations. Leave out altogether to disable.//  Of limited use in this case since faceZone faces not handled.
  nFeatureSnapIter 10;
  multiRegionFeatureSnap yes;
} 	// Settings for the layer addition.

addLayersControls
{
  relativeSizes yes;
  layers
  {
    Wall
    {
      nSurfaceLayers 3;
    }
  } 	// Per final patch (so not geometry!) the layer information// Expansion factor for layer mesh
  expansionRatio 1; 	// Wanted thickness of final added cell layer. If multiple layers// is the thickness of the layer furthest away from the wall.// Relative to undistorted size of cell outside layer.// See relativeSizes parameter.
  finalLayerThickness 0.2; 	// Minimum thickness of cell layer. If for any reason layer// cannot be above minThickness do not add layer.// Relative to undistorted size of cell outside layer.
  minThickness 0.01; 	// If points get not extruded do nGrow layers of connected faces that are// also not grown. This helps convergence of the layer addition process// close to features.// Note: changed(corrected) w.r.t 17x! (didn't do anything in 17x)
  nGrow 0; 	// Advanced settings// When not to extrude surface. 0 is flat surface, 90 is when two faces// are perpendicular
  featureAngle 30; 	// Maximum number of snapping relaxation iterations. Should stop// before upon reaching a correct mesh.
  nRelaxIter 20; 	// Number of smoothing iterations of surface normals
  nSmoothSurfaceNormals 3; 	// Number of smoothing iterations of interior mesh movement direction
  nSmoothNormals 3; 	// Smooth layer thickness over surface patches
  nSmoothThickness 10; 	// Stop layer growth on highly warped cells
  maxFaceThicknessRatio 0.9; 	// Reduce layer growth where ratio thickness to medial// distance is large
  maxThicknessToMedialRatio 0.9; 	// Angle used to pick up medial axis points// Note: changed(corrected) w.r.t 17x! 90 degrees corresponds to 130 in 17x.
  minMedianAxisAngle 90; 	// Create buffer region for new layer terminations
  nBufferCellsNoExtrude 0; 	// Overall max number of layer addition iterations. The mesher will exit// if it reaches this number of iterations; possibly with an illegal// mesh.
  nLayerIter 50;
} 	// Generic mesh quality settings. At any undoable phase these determine// where to undo.

meshQualityControls
{
#include "meshQualityDict"
  nSmoothScale 4; 	// Advanced//- Number of error distribution iterations//- Amount to scale back displacement at error points
  errorReduction 0.75;
} 	// Advanced// Merge tolerance. Is fraction of overall bounding box of initial mesh.// Note: the write tolerance needs to be higher than this.

mergeTolerance 1e-06; 	// ************************************************************************* //

